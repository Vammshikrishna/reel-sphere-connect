CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Enum Types
CREATE TYPE public.room_type AS ENUM (
    'public',
    'private',
    'secret'
);

-- Tables
CREATE TABLE IF NOT EXISTS public.room_categories (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    name text NOT NULL UNIQUE,
    description text
);

CREATE TABLE IF NOT EXISTS public.discussion_rooms (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    description text,
    creator_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    category_id uuid REFERENCES public.room_categories(id) ON DELETE SET NULL,
    tags text[],
    last_activity_at timestamp with time zone DEFAULT now(),
    room_type public.room_type DEFAULT 'public'::room_type
);

CREATE TABLE IF NOT EXISTS public.room_messages (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    room_id uuid NOT NULL REFERENCES public.discussion_rooms(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    content text NOT NULL,
    is_read boolean DEFAULT false
);

CREATE TABLE IF NOT EXISTS public.message_reactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    message_id uuid NOT NULL REFERENCES public.room_messages(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    emoji text NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT unique_reaction UNIQUE (message_id, user_id, emoji)
);

CREATE TABLE IF NOT EXISTS public.conversations (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    user1_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    user2_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    UNIQUE (user1_id, user2_id)
);

CREATE TABLE IF NOT EXISTS public.messages (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    conversation_id uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    sender_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    content text NOT NULL,
    is_read boolean DEFAULT false
);

CREATE TABLE IF NOT EXISTS public.likes (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id uuid NOT NULL, -- Assuming a posts table exists
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    UNIQUE (post_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.comments (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id uuid NOT NULL, -- Assuming a posts table exists
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    content text NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    parent_comment_id uuid REFERENCES public.comments(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.shares (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id uuid NOT NULL, -- Assuming a posts table exists
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    UNIQUE (post_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid NOT NULL references auth.users(id) on delete cascade PRIMARY KEY,
  updated_at timestamp with time zone,
  username text UNIQUE,
  avatar_url text,
  website text,
  about_me text,
  experience text,
  instagram_url text,
  youtube_url text,

  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

CREATE TABLE "public"."user_skills" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "skill_name" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE "public"."user_skills" OWNER TO "postgres";

CREATE TABLE "public"."user_experience" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "company" "text" NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date",
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE "public"."user_experience" OWNER TO "postgres";

ALTER TABLE "public"."user_experience" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."user_experience_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

ALTER TABLE "public"."user_skills" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."user_skills_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

ALTER TABLE ONLY "public"."user_experience"
    ADD CONSTRAINT "user_experience_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_skills"
    ADD CONSTRAINT "user_skills_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_experience"
    ADD CONSTRAINT "user_experience_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_skills"
    ADD CONSTRAINT "user_skills_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;

CREATE TABLE "public"."room_members" (
    "room_id" uuid NOT NULL,
    "user_id" uuid NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL
);

ALTER TABLE "public"."room_members" OWNER TO "postgres";

ALTER TABLE ONLY "public"."room_members"
    ADD CONSTRAINT "room_members_pkey" PRIMARY KEY ("room_id", "user_id");

ALTER TABLE ONLY "public"."room_members"
    ADD CONSTRAINT "room_members_room_id_fkey" FOREIGN KEY (room_id) REFERENCES public.discussion_rooms(id) ON DELETE CASCADE;

ALTER TABLE ONLY "public"."room_members"
    ADD CONSTRAINT "room_members_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


-- Create a new table to manage join requests for private rooms
CREATE TABLE "public"."room_join_requests" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "room_id" uuid NOT NULL,
    "user_id" uuid NOT NULL,
    "status" text DEFAULT 'pending'::text NOT NULL
);

ALTER TABLE "public"."room_join_requests" OWNER TO "postgres";
CREATE SEQUENCE "public"."room_join_requests_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER TABLE "public"."room_join_requests_id_seq" OWNER TO "postgres";
ALTER SEQUENCE "public"."room_join_requests_id_seq" OWNED BY "public"."room_join_requests"."id";
ALTER TABLE ONLY "public"."room_join_requests" ALTER COLUMN "id" SET DEFAULT nextval('public.room_join_requests_id_seq'::regclass);
ALTER TABLE ONLY "public"."room_join_requests"
    ADD CONSTRAINT "room_join_requests_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "public"."room_join_requests"
    ADD CONSTRAINT "room_join_requests_room_id_fkey" FOREIGN KEY (room_id) REFERENCES public.discussion_rooms(id) ON DELETE CASCADE;
ALTER TABLE ONLY "public"."room_join_requests"
    ADD CONSTRAINT "room_join_requests_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

-- Functions
CREATE OR REPLACE FUNCTION public.update_room_last_activity()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.discussion_rooms
    SET last_activity_at = now()
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_user_conversations(p_user_id uuid)
RETURNS TABLE(conversation_id uuid, other_user_id uuid, other_user_username text, last_message_content text, last_message_created_at timestamp with time zone) AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id AS conversation_id,
        CASE
            WHEN c.user1_id = p_user_id THEN c.user2_id
            ELSE c.user1_id
        END AS other_user_id,
        u.raw_user_meta_data->>'username' AS other_user_username,
        (SELECT content FROM public.messages m WHERE m.conversation_id = c.id ORDER BY m.created_at DESC LIMIT 1) AS last_message_content,
        (SELECT created_at FROM public.messages m WHERE m.conversation_id = c.id ORDER BY m.created_at DESC LIMIT 1) AS last_message_created_at
    FROM
        public.conversations c
    JOIN
        auth.users u ON u.id = (CASE WHEN c.user1_id = p_user_id THEN c.user2_id ELSE c.user1_id END)
    WHERE
        c.user1_id = p_user_id OR c.user2_id = p_user_id
    ORDER BY
        (SELECT created_at FROM public.messages m WHERE m.conversation_id = c.id ORDER BY m.created_at DESC LIMIT 1) DESC;
END; 
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.create_room_and_category(p_name text, p_description text, p_category_name text, p_room_type public.room_type)
RETURNS uuid AS $$
DECLARE
    v_category_id uuid;
    v_room_id uuid;
BEGIN
    -- Upsert category
    INSERT INTO public.room_categories (name) VALUES (p_category_name) ON CONFLICT (name) DO UPDATE SET name = p_category_name RETURNING id INTO v_category_id;
    
    -- Insert room
    INSERT INTO public.discussion_rooms (name, description, creator_id, category_id, room_type) 
    VALUES (p_name, p_description, auth.uid(), v_category_id, p_room_type)
    RETURNING id INTO v_room_id;
    
    RETURN v_room_id;
END;
$$ LANGUAGE plpgsql;

create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, username, avatar_url)
  values (new.id, new.raw_user_meta_data->>'username', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

-- Triggers
CREATE TRIGGER on_new_message_update_room_activity
AFTER INSERT ON public.room_messages
FOR EACH ROW
EXECUTE FUNCTION public.update_room_last_activity();

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- RLS Policies
ALTER TABLE public.discussion_rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.message_reactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."user_skills" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."user_experience" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."room_members" ENABLE ROW LEVEL SECURITY;

-- Policies for discussion_rooms
CREATE POLICY "Users can view all public rooms" ON public.discussion_rooms FOR SELECT USING (room_type = 'public');
CREATE POLICY "Users can create rooms" ON public.discussion_rooms FOR INSERT WITH CHECK (auth.uid() = creator_id);
CREATE POLICY "Creators can update their own rooms" ON public.discussion_rooms FOR UPDATE USING (auth.uid() = creator_id);
CREATE POLICY "Creators can delete their own rooms" ON public.discussion_rooms FOR DELETE USING (auth.uid() = creator_id);
CREATE POLICY "Users can view private rooms they are members of" ON public.discussion_rooms FOR SELECT
    USING ((room_type = 'private' AND (EXISTS ( SELECT 1
   FROM public.room_members
  WHERE ((room_members.room_id = discussion_rooms.id) AND (room_members.user_id = auth.uid()))))) OR (EXISTS ( SELECT 1
   FROM public.room_join_requests
  WHERE ((room_join_requests.room_id = discussion_rooms.id) AND (room_join_requests.user_id = auth.uid())))));


-- Policies for room_messages
CREATE POLICY "Users in a room can view messages" ON public.room_messages FOR SELECT USING (
  (room_id IN (SELECT id FROM public.discussion_rooms WHERE room_type = 'public')) OR
  (EXISTS (SELECT 1 FROM public.discussion_rooms WHERE id = room_id AND creator_id = auth.uid()))
);
CREATE POLICY "Users can send messages in rooms they are part of" ON public.room_messages FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own messages" ON public.room_messages FOR DELETE USING (auth.uid() = user_id);

-- Policies for message_reactions
CREATE POLICY "Users can view all reactions" ON public.message_reactions FOR SELECT USING (true);
CREATE POLICY "Users can insert their own reactions" ON public.message_reactions FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own reactions" ON public.message_reactions FOR DELETE USING (auth.uid() = user_id);

-- Policies for conversations
CREATE POLICY "Users can view their own conversations" ON public.conversations FOR SELECT USING (auth.uid() = user1_id OR auth.uid() = user2_id);
CREATE POLICY "Users can create conversations" ON public.conversations FOR INSERT WITH CHECK (auth.uid() = user1_id OR auth.uid() = user2_id);

-- Policies for messages
CREATE POLICY "Users can view messages in their conversations" ON public.messages FOR SELECT USING (conversation_id IN (SELECT id FROM public.conversations));
CREATE POLICY "Users can send messages in their conversations" ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);

-- Policies for profiles
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);


CREATE POLICY "Enable read access for all users" ON "public"."user_skills" FOR SELECT USING (true);
CREATE POLICY "Enable insert for authenticated users only" ON "public"."user_skills" FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Enable update for users based on user_id" ON "public"."user_skills" FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable delete for users based on user_id" ON "public"."user_skills" FOR DELETE USING (auth.uid() = user_id);

CREATE POLICY "Enable read access for all users" ON "public"."user_experience" FOR SELECT USING (true);
CREATE POLICY "Enable insert for authenticated users only" ON "public"."user_experience" FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Enable update for users based on user_id" ON "public"."user_experience" FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable delete for users based on user_id" ON "public"."user_experience" FOR DELETE USING (auth.uid() = user_id);

-- Policies for room_members
CREATE POLICY "Users can view members of rooms they are in" ON "public"."room_members" FOR SELECT USING (room_id IN (SELECT room_id FROM public.room_members WHERE user_id = auth.uid()));
CREATE POLICY "Room creators can add members" ON "public"."room_members" FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.discussion_rooms WHERE id = room_id AND creator_id = auth.uid()));
CREATE POLICY "Users can leave rooms" ON "public"."room_members" FOR DELETE USING (user_id = auth.uid());


-- Add policies for the new table
CREATE POLICY "Users can create their own join requests" ON public.room_join_requests FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Room creators can view join requests" ON public.room_join_requests FOR SELECT USING (
    (EXISTS (SELECT 1 FROM public.discussion_rooms WHERE id = room_id AND creator_id = auth.uid()))
);
CREATE POLICY "Room creators can update join requests" ON public.room_join_requests FOR UPDATE USING (
    (EXISTS (SELECT 1 FROM public.discussion_rooms WHERE id = room_id AND creator_id = auth.uid()))
);
CREATE POLICY "Room creators can delete join requests" ON public.room_join_requests FOR DELETE USING (
    (EXISTS (SELECT 1 FROM public.discussion_rooms WHERE id = room_id AND creator_id = auth.uid()))
);

-- Default Category
INSERT INTO public.room_categories (name, description) VALUES ('General', 'General discussions') ON CONFLICT (name) DO NOTHING;
UPDATE public.discussion_rooms SET category_id = (SELECT id FROM public.room_categories WHERE name = 'General') WHERE category_id IS NULL;
