-- ============================================================================
-- COMBINED MIGRATION FILE - ALL MIGRATIONS IN ONE
-- ============================================================================
-- Generated: 2025-11-26 14:05:35
-- Total Migrations: 30
-- ============================================================================
-- This file combines all individual migration files in chronological order
-- Use this for fresh database setup or production deployment
-- ============================================================================

-- ============================================================================
-- Migration: 20250121000000_fresh_init.sql
-- ============================================================================
-- 20250121000000_fresh_init.sql

-- 1. Extensions & Types
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

DO $$ BEGIN
    CREATE TYPE public.project_space_type AS ENUM ('public', 'private', 'secret');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- 2. Profiles (Base User Data)
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    updated_at timestamp with time zone,
    username text UNIQUE,
    full_name text,
    avatar_url text,
    website text,
    bio text,
    location text,
    experience text,
    craft text,
    instagram_url text,
    youtube_url text,
    CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

-- 3. Project Spaces & Categories
CREATE TABLE IF NOT EXISTS public.project_space_categories (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    name text NOT NULL UNIQUE,
    description text
);

CREATE TABLE IF NOT EXISTS public.project_spaces (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    description text,
    creator_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    category_id uuid REFERENCES public.project_space_categories(id) ON DELETE SET NULL,
    tags text[],
    last_activity_at timestamp with time zone DEFAULT now(),
    project_space_type public.project_space_type DEFAULT 'public'::project_space_type,
    -- Extended columns
    status TEXT, 
    location TEXT, 
    genre TEXT[], 
    required_roles TEXT[],
    budget_min NUMERIC, 
    budget_max NUMERIC, 
    start_date DATE, 
    end_date DATE
);

CREATE TABLE IF NOT EXISTS public.project_space_members (
    project_space_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    PRIMARY KEY (project_space_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.project_space_join_requests (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    project_space_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status text DEFAULT 'pending'::text NOT NULL
);

CREATE TABLE IF NOT EXISTS public.project_space_bookmarks (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    project_space_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE(user_id, project_space_id)
);

-- 4. Tasks (Project Management)
CREATE TABLE IF NOT EXISTS public.tasks (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    project_space_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    name text NOT NULL,
    description text,
    due_date date,
    assignee_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    is_completed boolean DEFAULT false,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);

-- 5. Feed & Posts
CREATE TABLE IF NOT EXISTS public.posts (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    author_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content text NOT NULL,
    media_url text,
    media_type text,
    tags text[],
    like_count integer DEFAULT 0,
    comment_count integer DEFAULT 0,
    share_count integer DEFAULT 0,
    has_ai_generated boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE IF NOT EXISTS public.likes (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id uuid NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    UNIQUE (post_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.comments (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id uuid NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    content text NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    parent_comment_id uuid REFERENCES public.comments(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.shares (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id uuid NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    UNIQUE (post_id, user_id)
);

-- 6. Discussion Rooms
CREATE TABLE IF NOT EXISTS public.room_categories (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    name text NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS public.discussion_rooms (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    title text NOT NULL,
    name text NOT NULL, -- kept for compatibility
    description text,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    is_public boolean DEFAULT true,
    member_count integer DEFAULT 0,
    room_type text DEFAULT 'public',
    project_id uuid REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    creator_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    category_id uuid REFERENCES public.room_categories(id) ON DELETE SET NULL
);

CREATE TABLE IF NOT EXISTS public.room_members (
    room_id uuid NOT NULL REFERENCES public.discussion_rooms(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at timestamp with time zone NOT NULL DEFAULT now(),
    PRIMARY KEY (room_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.room_messages (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id uuid NOT NULL REFERENCES public.discussion_rooms(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content text NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    priority text DEFAULT 'normal',
    visibility_role text DEFAULT 'everyone'
);

CREATE TABLE IF NOT EXISTS public.room_join_requests (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    room_id uuid NOT NULL REFERENCES public.discussion_rooms(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    status text DEFAULT 'pending'::text NOT NULL
);

-- 7. Direct Messaging (Conversations)
CREATE TABLE IF NOT EXISTS public.conversations (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    user1_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    user2_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    UNIQUE (user1_id, user2_id)
);

CREATE TABLE IF NOT EXISTS public.messages (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    conversation_id uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    sender_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    content text NOT NULL,
    is_read boolean DEFAULT false
);

-- 8. Notifications
CREATE TABLE IF NOT EXISTS public.notifications (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type text NOT NULL,
    title text NOT NULL,
    message text NOT NULL,
    action_url text,
    related_id uuid,
    related_type text,
    priority text DEFAULT 'medium' CHECK (priority IN ('high', 'medium', 'low')),
    is_read boolean DEFAULT false,
    is_actionable boolean DEFAULT false,
    metadata jsonb,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 9. Announcements
CREATE TABLE IF NOT EXISTS public.announcements (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    title text NOT NULL,
    content text NOT NULL,
    posted_at timestamp with time zone DEFAULT now() NOT NULL,
    author_id uuid REFERENCES auth.users(id) ON DELETE SET NULL
);

-- 10. User Details (Skills & Experience)
CREATE TABLE IF NOT EXISTS public.user_skills (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    skill_name text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE IF NOT EXISTS public.user_experience (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    title text NOT NULL,
    company text NOT NULL,
    start_date date NOT NULL,
    end_date date,
    description text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- ============================================================================
-- FUNCTIONS & TRIGGERS
-- ============================================================================

-- Handle New User (Profile Creation)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, full_name, avatar_url)
  VALUES (
    new.id, 
    new.raw_user_meta_data->>'username', 
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url'
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Update Updated At
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_posts_updated_at ON public.posts;
CREATE TRIGGER update_posts_updated_at BEFORE UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_notifications_updated_at ON public.notifications;
CREATE TRIGGER update_notifications_updated_at BEFORE UPDATE ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Update Room Member Count
CREATE OR REPLACE FUNCTION public.update_room_member_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.discussion_rooms SET member_count = member_count + 1 WHERE id = NEW.room_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.discussion_rooms SET member_count = GREATEST(0, member_count - 1) WHERE id = OLD.room_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_member_count_on_join ON public.room_members;
CREATE TRIGGER update_member_count_on_join AFTER INSERT ON public.room_members FOR EACH ROW EXECUTE FUNCTION public.update_room_member_count();

DROP TRIGGER IF EXISTS update_member_count_on_leave ON public.room_members;
CREATE TRIGGER update_member_count_on_leave AFTER DELETE ON public.room_members FOR EACH ROW EXECUTE FUNCTION public.update_room_member_count();

-- ============================================================================
-- RLS POLICIES (Permissive & Simple)
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_spaces ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_space_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_space_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_space_bookmarks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_space_join_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.discussion_rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_join_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.announcements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_experience ENABLE ROW LEVEL SECURITY;

-- Profiles
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone" ON public.profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
CREATE POLICY "Users can insert their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Project Spaces
DROP POLICY IF EXISTS "Anyone can view project spaces" ON public.project_spaces;
CREATE POLICY "Anyone can view project spaces" ON public.project_spaces FOR SELECT USING (true);

DROP POLICY IF EXISTS "Authenticated users can create project spaces" ON public.project_spaces;
CREATE POLICY "Authenticated users can create project spaces" ON public.project_spaces FOR INSERT WITH CHECK (auth.uid() = creator_id);

DROP POLICY IF EXISTS "Creators can update their project spaces" ON public.project_spaces;
CREATE POLICY "Creators can update their project spaces" ON public.project_spaces FOR UPDATE USING (auth.uid() = creator_id);

DROP POLICY IF EXISTS "Creators can delete their project spaces" ON public.project_spaces;
CREATE POLICY "Creators can delete their project spaces" ON public.project_spaces FOR DELETE USING (auth.uid() = creator_id);

-- Project Space Members
DROP POLICY IF EXISTS "Anyone can view project members" ON public.project_space_members;
CREATE POLICY "Anyone can view project members" ON public.project_space_members FOR SELECT USING (true);

DROP POLICY IF EXISTS "Creators can manage members" ON public.project_space_members;
CREATE POLICY "Creators can manage members" ON public.project_space_members FOR ALL USING (
    EXISTS (SELECT 1 FROM public.project_spaces WHERE id = project_space_id AND creator_id = auth.uid())
);

DROP POLICY IF EXISTS "Users can join/leave" ON public.project_space_members;
CREATE POLICY "Users can join/leave" ON public.project_space_members FOR ALL USING (user_id = auth.uid());

-- Project Categories
DROP POLICY IF EXISTS "Anyone can view categories" ON public.project_space_categories;
CREATE POLICY "Anyone can view categories" ON public.project_space_categories FOR SELECT USING (true);

-- Bookmarks
DROP POLICY IF EXISTS "Users can manage their own bookmarks" ON public.project_space_bookmarks;
CREATE POLICY "Users can manage their own bookmarks" ON public.project_space_bookmarks FOR ALL USING (auth.uid() = user_id);

-- Posts
DROP POLICY IF EXISTS "Anyone can view posts" ON public.posts;
CREATE POLICY "Anyone can view posts" ON public.posts FOR SELECT USING (true);

DROP POLICY IF EXISTS "Authenticated users can create posts" ON public.posts;
CREATE POLICY "Authenticated users can create posts" ON public.posts FOR INSERT WITH CHECK (auth.uid() = author_id);

DROP POLICY IF EXISTS "Authors can update/delete their posts" ON public.posts;
CREATE POLICY "Authors can update/delete their posts" ON public.posts FOR ALL USING (auth.uid() = author_id);

-- Discussion Rooms
DROP POLICY IF EXISTS "Anyone can view public rooms" ON public.discussion_rooms;
CREATE POLICY "Anyone can view public rooms" ON public.discussion_rooms FOR SELECT USING (is_public = true OR auth.uid() IS NOT NULL);

DROP POLICY IF EXISTS "Authenticated users can create rooms" ON public.discussion_rooms;
CREATE POLICY "Authenticated users can create rooms" ON public.discussion_rooms FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

DROP POLICY IF EXISTS "Creators can update/delete rooms" ON public.discussion_rooms;
CREATE POLICY "Creators can update/delete rooms" ON public.discussion_rooms FOR ALL USING (creator_id = auth.uid());

-- Room Messages
DROP POLICY IF EXISTS "Anyone can view messages" ON public.room_messages;
CREATE POLICY "Anyone can view messages" ON public.room_messages FOR SELECT USING (true);

DROP POLICY IF EXISTS "Authenticated users can send messages" ON public.room_messages;
CREATE POLICY "Authenticated users can send messages" ON public.room_messages FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their own messages" ON public.room_messages;
CREATE POLICY "Users can delete their own messages" ON public.room_messages FOR DELETE USING (auth.uid() = user_id);

-- Room Join Requests
DROP POLICY IF EXISTS "Users can create join requests" ON public.room_join_requests;
CREATE POLICY "Users can create join requests" ON public.room_join_requests FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Room creators can view join requests" ON public.room_join_requests;
CREATE POLICY "Room creators can view join requests" ON public.room_join_requests FOR SELECT USING (
    EXISTS (SELECT 1 FROM public.discussion_rooms WHERE id = room_id AND creator_id = auth.uid())
);

DROP POLICY IF EXISTS "Room creators can manage join requests" ON public.room_join_requests;
CREATE POLICY "Room creators can manage join requests" ON public.room_join_requests FOR ALL USING (
    EXISTS (SELECT 1 FROM public.discussion_rooms WHERE id = room_id AND creator_id = auth.uid())
);

-- Notifications
DROP POLICY IF EXISTS "Users can view/manage their own notifications" ON public.notifications;
CREATE POLICY "Users can view/manage their own notifications" ON public.notifications FOR ALL USING (auth.uid() = user_id);

-- Announcements
DROP POLICY IF EXISTS "Anyone can view announcements" ON public.announcements;
CREATE POLICY "Anyone can view announcements" ON public.announcements FOR SELECT USING (true);

-- General fallback for other tables (Likes, Comments, etc.)
DROP POLICY IF EXISTS "Public view likes" ON public.likes;
CREATE POLICY "Public view likes" ON public.likes FOR SELECT USING (true);

DROP POLICY IF EXISTS "User manage likes" ON public.likes;
CREATE POLICY "User manage likes" ON public.likes FOR ALL USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Public view comments" ON public.comments;
CREATE POLICY "Public view comments" ON public.comments FOR SELECT USING (true);

DROP POLICY IF EXISTS "User manage comments" ON public.comments;
CREATE POLICY "User manage comments" ON public.comments FOR ALL USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Public view shares" ON public.shares;
CREATE POLICY "Public view shares" ON public.shares FOR SELECT USING (true);

DROP POLICY IF EXISTS "User manage shares" ON public.shares;
CREATE POLICY "User manage shares" ON public.shares FOR ALL USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "User manage conversations" ON public.conversations;
CREATE POLICY "User manage conversations" ON public.conversations FOR ALL USING (auth.uid() = user1_id OR auth.uid() = user2_id);

DROP POLICY IF EXISTS "User manage messages" ON public.messages;
CREATE POLICY "User manage messages" ON public.messages FOR ALL USING (auth.uid() = sender_id OR conversation_id IN (SELECT id FROM public.conversations WHERE user1_id = auth.uid() OR user2_id = auth.uid()));

-- ============================================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_spaces ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_space_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_space_join_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_space_bookmarks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.discussion_rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_join_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.announcements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_skills ENABLE ROW LEVEL SECURITY;

-- Permissive policies for development (allow all authenticated users)
CREATE POLICY "Allow all for authenticated users" ON public.profiles FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.project_spaces FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.project_space_members FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.project_space_join_requests FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.project_space_bookmarks FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.tasks FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.posts FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.comments FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.likes FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.shares FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.discussion_rooms FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.room_members FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.room_messages FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.room_join_requests FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.conversations FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.messages FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.notifications FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.announcements FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all for authenticated users" ON public.user_skills FOR ALL USING (auth.role() = 'authenticated');

-- ============================================================================
-- DATA SEEDING
-- ============================================================================

INSERT INTO public.project_space_categories (name, description) VALUES 
('Film', 'Feature films, short films, and documentaries'),
('TV', 'Television series and pilots'),
('Commercial', 'Commercials and advertising'),
('Music Video', 'Music videos'),
('Web Series', 'Web series and online content')
ON CONFLICT (name) DO NOTHING;

INSERT INTO public.room_categories (name) VALUES 
('General'),
('Cinematography'),
('Directing'),
('Production'),
('Post-Production'),
('Screenwriting'),
('Sound Design'),
('Visual Effects')
ON CONFLICT (name) DO NOTHING;


-- ============================================================================
-- Migration: 20251201000000_portfolios_storage_policies.sql
-- ============================================================================
-- Migration: Add RLS policies for the 'portfolios' storage bucket
-- Authenticated users can read objects in the bucket
-- Authenticated users can upload (insert) objects
-- Owners can delete their own objects

-- Note: RLS on storage.objects is already enabled by Supabase.

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "authenticated read portfolios" ON storage.objects;
DROP POLICY IF EXISTS "authenticated upload portfolios" ON storage.objects;
DROP POLICY IF EXISTS "owner delete portfolios" ON storage.objects;

-- SELECT policy: only authenticated users can read objects in 'portfolios'
CREATE POLICY "authenticated read portfolios"
  ON storage.objects
  FOR SELECT
  USING (
    auth.role() = 'authenticated'
    AND bucket_id = 'portfolios'
  );

-- INSERT policy: only authenticated users can upload objects to 'portfolios'
CREATE POLICY "authenticated upload portfolios"
  ON storage.objects
  FOR INSERT
  WITH CHECK (
    auth.role() = 'authenticated'
    AND bucket_id = 'portfolios'
  );

-- DELETE policy: owners can delete their own objects in 'portfolios'
CREATE POLICY "owner delete portfolios"
  ON storage.objects
  FOR DELETE
  USING (
    auth.role() = 'authenticated'
    AND bucket_id = 'portfolios'
    AND owner = auth.uid()
  );


-- ============================================================================
-- Migration: 20251201000001_create_portfolios_bucket.sql
-- ============================================================================
-- Migration: Create the 'portfolios' storage bucket
-- This inserts the bucket definition into the storage.buckets table

INSERT INTO storage.buckets (id, name, public)
VALUES ('portfolios', 'portfolios', true)
ON CONFLICT (id) DO NOTHING;


-- ============================================================================
-- Migration: 20251201000002_fix_bucket_permissions.sql
-- ============================================================================
-- Migration: Fix permissions for storage.buckets
-- The client cannot see the bucket, causing "Bucket not found" errors.
-- This adds a policy to allow authenticated users to list/see buckets.

-- Drop existing policies if they exist to avoid errors
DROP POLICY IF EXISTS "Authenticated can list buckets" ON storage.buckets;
DROP POLICY IF EXISTS "Public can list public buckets" ON storage.buckets;

-- Allow authenticated users to select (list) buckets
CREATE POLICY "Authenticated can list buckets"
ON storage.buckets FOR SELECT
TO authenticated
USING ( true );

-- Also allow public access to public buckets (for good measure)
CREATE POLICY "Public can list public buckets"
ON storage.buckets FOR SELECT
TO public
USING ( public = true );


-- ============================================================================
-- Migration: 20251201000003_create_avatars_bucket.sql
-- ============================================================================
-- Migration: Create 'avatars' bucket and policies
-- 1. Create the bucket
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;

-- 2. RLS Policies for 'avatars'

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Public can view avatars" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated can upload avatars" ON storage.objects;
DROP POLICY IF EXISTS "Owners can update avatars" ON storage.objects;
DROP POLICY IF EXISTS "Owners can delete avatars" ON storage.objects;

-- SELECT: Public access (anyone can view avatars)
CREATE POLICY "Public can view avatars"
ON storage.objects FOR SELECT
USING ( bucket_id = 'avatars' );

-- INSERT: Authenticated users can upload avatars
CREATE POLICY "Authenticated can upload avatars"
ON storage.objects FOR INSERT
WITH CHECK (
  auth.role() = 'authenticated'
  AND bucket_id = 'avatars'
);

-- UPDATE: Owners can update their own avatars
CREATE POLICY "Owners can update avatars"
ON storage.objects FOR UPDATE
USING (
  auth.role() = 'authenticated'
  AND bucket_id = 'avatars'
  AND owner = auth.uid()
);

-- DELETE: Owners can delete their own avatars
CREATE POLICY "Owners can delete avatars"
ON storage.objects FOR DELETE
USING (
  auth.role() = 'authenticated'
  AND bucket_id = 'avatars'
  AND owner = auth.uid()
);


-- ============================================================================
-- Migration: 20251201000004_create_user_connections.sql
-- ============================================================================
-- Migration: Create user_connections table and RLS policies
-- Create table to store connections between users
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE IF NOT EXISTS user_connections (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  follower_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  following_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  status text NOT NULL CHECK (status IN ('pending', 'accepted')),
  created_at timestamp with time zone DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE user_connections ENABLE ROW LEVEL SECURITY;

-- Policy: Authenticated users can SELECT rows where they are involved
CREATE POLICY "Authenticated can view own connections"
ON user_connections FOR SELECT
TO authenticated
USING ( follower_id = auth.uid() OR following_id = auth.uid() );

-- Policy: Authenticated users can INSERT a new connection (request)
CREATE POLICY "Authenticated can create connection request"
ON user_connections FOR INSERT
TO authenticated
WITH CHECK ( follower_id = auth.uid() );

-- Policy: Authenticated users can UPDATE status of a connection they own (i.e., where they are follower)
CREATE POLICY "Authenticated can update own connection"
ON user_connections FOR UPDATE
TO authenticated
USING ( follower_id = auth.uid() )
WITH CHECK ( follower_id = auth.uid() );

-- Policy: Authenticated users can DELETE a connection they own
CREATE POLICY "Authenticated can delete own connection"
ON user_connections FOR DELETE
TO authenticated
USING ( follower_id = auth.uid() );


-- ============================================================================
-- Migration: 20251201000005_create_portfolio_items.sql
-- ============================================================================
-- 20251201000005_create_portfolio_items.sql

-- Create portfolio_items table
CREATE TABLE IF NOT EXISTS public.portfolio_items (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title text NOT NULL,
    description text,
    media_url text,
    media_type text, -- 'image', 'video', 'audio', 'document'
    project_type text,
    role text,
    completion_date date,
    tags text[],
    is_featured boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Enable RLS
ALTER TABLE public.portfolio_items ENABLE ROW LEVEL SECURITY;

-- Create policies
DROP POLICY IF EXISTS "Public portfolio items are viewable by everyone" ON public.portfolio_items;
CREATE POLICY "Public portfolio items are viewable by everyone" ON public.portfolio_items FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can insert their own portfolio items" ON public.portfolio_items;
CREATE POLICY "Users can insert their own portfolio items" ON public.portfolio_items FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own portfolio items" ON public.portfolio_items;
CREATE POLICY "Users can update their own portfolio items" ON public.portfolio_items FOR UPDATE USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their own portfolio items" ON public.portfolio_items;
CREATE POLICY "Users can delete their own portfolio items" ON public.portfolio_items FOR DELETE USING (auth.uid() = user_id);

-- Create updated_at trigger
DROP TRIGGER IF EXISTS update_portfolio_items_updated_at ON public.portfolio_items;
CREATE TRIGGER update_portfolio_items_updated_at BEFORE UPDATE ON public.portfolio_items FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


-- ============================================================================
-- Migration: 20251201000006_create_project_space_tables.sql
-- ============================================================================
-- 20251201000006_create_project_space_tables.sql
-- Create all missing tables for project space functionality

-- 1. Files table for file management
CREATE TABLE IF NOT EXISTS public.files (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    name text NOT NULL,
    size bigint NOT NULL,
    url text NOT NULL,
    file_type text,
    uploaded_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 2. Call Sheets table
CREATE TABLE IF NOT EXISTS public.call_sheets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    date date NOT NULL,
    call_time time,
    location text,
    director text,
    director_phone text,
    producer text,
    producer_phone text,
    notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 3. Shot List table
CREATE TABLE IF NOT EXISTS public.shot_list (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    scene integer NOT NULL,
    shot integer NOT NULL,
    description text NOT NULL,
    status text DEFAULT 'pending',
    notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 4. Legal Documents table
CREATE TABLE IF NOT EXISTS public.legal_docs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    title text NOT NULL,
    description text,
    url text,
    document_type text,
    uploaded_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 5. Budget Items table
CREATE TABLE IF NOT EXISTS public.budget_items (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    category text NOT NULL,
    item_name text NOT NULL,
    estimated_cost numeric(12, 2),
    actual_cost numeric(12, 2),
    notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 6. Schedule Items table
CREATE TABLE IF NOT EXISTS public.schedule_items (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    title text NOT NULL,
    description text,
    start_date date NOT NULL,
    end_date date,
    status text DEFAULT 'scheduled',
    assigned_to uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Enable RLS on all tables
ALTER TABLE public.files ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.call_sheets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.shot_list ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.legal_docs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.budget_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.schedule_items ENABLE ROW LEVEL SECURITY;

-- RLS Policies for Files
DROP POLICY IF EXISTS "Project members can view files" ON public.files;
CREATE POLICY "Project members can view files" ON public.files FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = files.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = files.project_id AND creator_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "Project members can upload files" ON public.files;
CREATE POLICY "Project members can upload files" ON public.files FOR INSERT WITH CHECK (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = project_id AND creator_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "File uploaders can delete their files" ON public.files;
CREATE POLICY "File uploaders can delete their files" ON public.files FOR DELETE USING (
    uploaded_by = auth.uid() OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = files.project_id AND creator_id = auth.uid()
    )
);

-- RLS Policies for Call Sheets (same pattern for all)
DROP POLICY IF EXISTS "Project members can view call sheets" ON public.call_sheets;
CREATE POLICY "Project members can view call sheets" ON public.call_sheets FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = call_sheets.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = call_sheets.project_id AND creator_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "Project members can manage call sheets" ON public.call_sheets;
CREATE POLICY "Project members can manage call sheets" ON public.call_sheets FOR ALL USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = call_sheets.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = call_sheets.project_id AND creator_id = auth.uid()
    )
);

-- RLS Policies for Shot List
DROP POLICY IF EXISTS "Project members can view shot list" ON public.shot_list;
CREATE POLICY "Project members can view shot list" ON public.shot_list FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = shot_list.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = shot_list.project_id AND creator_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "Project members can manage shot list" ON public.shot_list;
CREATE POLICY "Project members can manage shot list" ON public.shot_list FOR ALL USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = shot_list.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = shot_list.project_id AND creator_id = auth.uid()
    )
);

-- RLS Policies for Legal Docs
DROP POLICY IF EXISTS "Project members can view legal docs" ON public.legal_docs;
CREATE POLICY "Project members can view legal docs" ON public.legal_docs FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = legal_docs.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = legal_docs.project_id AND creator_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "Project members can manage legal docs" ON public.legal_docs;
CREATE POLICY "Project members can manage legal docs" ON public.legal_docs FOR ALL USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = legal_docs.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = legal_docs.project_id AND creator_id = auth.uid()
    )
);

-- RLS Policies for Budget Items
DROP POLICY IF EXISTS "Project members can view budget" ON public.budget_items;
CREATE POLICY "Project members can view budget" ON public.budget_items FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = budget_items.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = budget_items.project_id AND creator_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "Project members can manage budget" ON public.budget_items;
CREATE POLICY "Project members can manage budget" ON public.budget_items FOR ALL USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = budget_items.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = budget_items.project_id AND creator_id = auth.uid()
    )
);

-- RLS Policies for Schedule Items
DROP POLICY IF EXISTS "Project members can view schedule" ON public.schedule_items;
CREATE POLICY "Project members can view schedule" ON public.schedule_items FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = schedule_items.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = schedule_items.project_id AND creator_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "Project members can manage schedule" ON public.schedule_items;
CREATE POLICY "Project members can manage schedule" ON public.schedule_items FOR ALL USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members 
        WHERE project_space_id = schedule_items.project_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces 
        WHERE id = schedule_items.project_id AND creator_id = auth.uid()
    )
);

-- Create updated_at triggers
DROP TRIGGER IF EXISTS update_files_updated_at ON public.files;
CREATE TRIGGER update_files_updated_at BEFORE UPDATE ON public.files FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_call_sheets_updated_at ON public.call_sheets;
CREATE TRIGGER update_call_sheets_updated_at BEFORE UPDATE ON public.call_sheets FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_shot_list_updated_at ON public.shot_list;
CREATE TRIGGER update_shot_list_updated_at BEFORE UPDATE ON public.shot_list FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_legal_docs_updated_at ON public.legal_docs;
CREATE TRIGGER update_legal_docs_updated_at BEFORE UPDATE ON public.legal_docs FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_budget_items_updated_at ON public.budget_items;
CREATE TRIGGER update_budget_items_updated_at BEFORE UPDATE ON public.budget_items FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_schedule_items_updated_at ON public.schedule_items;
CREATE TRIGGER update_schedule_items_updated_at BEFORE UPDATE ON public.schedule_items FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


-- ============================================================================
-- Migration: 20251201000007_create_project_files_bucket.sql
-- ============================================================================
-- 20251201000007_create_project_files_bucket.sql
-- Create storage bucket for project files

-- Create the bucket
INSERT INTO storage.buckets (id, name, public)
VALUES ('project-files', 'project-files', false)
ON CONFLICT (id) DO NOTHING;

-- RLS is already enabled on storage.objects

-- Policy: Project members can view files
DROP POLICY IF EXISTS "Project members can view project files" ON storage.objects;
CREATE POLICY "Project members can view project files" ON storage.objects FOR SELECT USING (
    bucket_id = 'project-files' AND (
        -- Extract project_id from path (format: project_id/filename)
        EXISTS (
            SELECT 1 FROM public.project_space_members 
            WHERE project_space_id::text = split_part(name, '/', 1) AND user_id = auth.uid()
        ) OR EXISTS (
            SELECT 1 FROM public.project_spaces 
            WHERE id::text = split_part(name, '/', 1) AND creator_id = auth.uid()
        )
    )
);

-- Policy: Project members can upload files
DROP POLICY IF EXISTS "Project members can upload project files" ON storage.objects;
CREATE POLICY "Project members can upload project files" ON storage.objects FOR INSERT WITH CHECK (
    bucket_id = 'project-files' AND (
        EXISTS (
            SELECT 1 FROM public.project_space_members 
            WHERE project_space_id::text = split_part(name, '/', 1) AND user_id = auth.uid()
        ) OR EXISTS (
            SELECT 1 FROM public.project_spaces 
            WHERE id::text = split_part(name, '/', 1) AND creator_id = auth.uid()
        )
    )
);

-- Policy: Project members can update their files
DROP POLICY IF EXISTS "Project members can update project files" ON storage.objects;
CREATE POLICY "Project members can update project files" ON storage.objects FOR UPDATE USING (
    bucket_id = 'project-files' AND (
        owner = auth.uid() OR EXISTS (
            SELECT 1 FROM public.project_spaces 
            WHERE id::text = split_part(name, '/', 1) AND creator_id = auth.uid()
        )
    )
);

-- Policy: File owners and project creators can delete files
DROP POLICY IF EXISTS "File owners can delete project files" ON storage.objects;
CREATE POLICY "File owners can delete project files" ON storage.objects FOR DELETE USING (
    bucket_id = 'project-files' AND (
        owner = auth.uid() OR EXISTS (
            SELECT 1 FROM public.project_spaces 
            WHERE id::text = split_part(name, '/', 1) AND creator_id = auth.uid()
        )
    )
);


-- ============================================================================
-- Migration: 20251201000008_create_legal_docs_bucket.sql
-- ============================================================================
-- Create legal-documents storage bucket
INSERT INTO storage.buckets (id, name, public)
VALUES ('legal-documents', 'legal-documents', false);

-- Enable RLS on storage.objects for legal-documents bucket
-- RLS is already enabled globally, we just need policies

-- Policy: Project members can view legal documents
DROP POLICY IF EXISTS "Project members can view legal documents" ON storage.objects;
CREATE POLICY "Project members can view legal documents"
ON storage.objects FOR SELECT
USING (
    bucket_id = 'legal-documents' AND
    (
        EXISTS (
            SELECT 1 FROM public.legal_docs
            JOIN public.project_space_members ON legal_docs.project_id = project_space_members.project_space_id
            WHERE legal_docs.url LIKE '%' || storage.objects.name || '%'
            AND project_space_members.user_id = auth.uid()
        ) OR
        EXISTS (
            SELECT 1 FROM public.legal_docs
            JOIN public.project_spaces ON legal_docs.project_id = project_spaces.id
            WHERE legal_docs.url LIKE '%' || storage.objects.name || '%'
            AND project_spaces.creator_id = auth.uid()
        )
    )
);

-- Policy: Project members can upload legal documents
DROP POLICY IF EXISTS "Project members can upload legal documents" ON storage.objects;
CREATE POLICY "Project members can upload legal documents"
ON storage.objects FOR INSERT
WITH CHECK (
    bucket_id = 'legal-documents' AND
    auth.uid() IS NOT NULL
);

-- Policy: Project members can update legal documents
DROP POLICY IF EXISTS "Project members can update legal documents" ON storage.objects;
CREATE POLICY "Project members can update legal documents"
ON storage.objects FOR UPDATE
USING (
    bucket_id = 'legal-documents' AND
    (
        EXISTS (
            SELECT 1 FROM public.legal_docs
            JOIN public.project_space_members ON legal_docs.project_id = project_space_members.project_space_id
            WHERE legal_docs.url LIKE '%' || storage.objects.name || '%'
            AND project_space_members.user_id = auth.uid()
        ) OR
        EXISTS (
            SELECT 1 FROM public.legal_docs
            JOIN public.project_spaces ON legal_docs.project_id = project_spaces.id
            WHERE legal_docs.url LIKE '%' || storage.objects.name || '%'
            AND project_spaces.creator_id = auth.uid()
        )
    )
);

-- Policy: Document uploaders and project creators can delete legal documents
DROP POLICY IF EXISTS "Document uploaders can delete legal documents" ON storage.objects;
CREATE POLICY "Document uploaders can delete legal documents"
ON storage.objects FOR DELETE
USING (
    bucket_id = 'legal-documents' AND
    (
        owner = auth.uid() OR
        EXISTS (
            SELECT 1 FROM public.legal_docs
            JOIN public.project_spaces ON legal_docs.project_id = project_spaces.id
            WHERE legal_docs.url LIKE '%' || storage.objects.name || '%'
            AND project_spaces.creator_id = auth.uid()
        )
    )
);


-- ============================================================================
-- Migration: 20251201000009_create_call_sheets_bucket.sql
-- ============================================================================
-- Create call-sheets storage bucket
INSERT INTO storage.buckets (id, name, public)
VALUES ('call-sheets', 'call-sheets', false);

-- Policy: Project members can view call sheets
DROP POLICY IF EXISTS "Project members can view call sheets" ON storage.objects;
CREATE POLICY "Project members can view call sheets"
ON storage.objects FOR SELECT
USING (
    bucket_id = 'call-sheets' AND
    (
        EXISTS (
            SELECT 1 FROM public.call_sheets
            JOIN public.project_space_members ON call_sheets.project_id = project_space_members.project_space_id
            WHERE call_sheets.notes LIKE '%' || storage.objects.name || '%'
            AND project_space_members.user_id = auth.uid()
        ) OR
        EXISTS (
            SELECT 1 FROM public.call_sheets
            JOIN public.project_spaces ON call_sheets.project_id = project_spaces.id
            WHERE call_sheets.notes LIKE '%' || storage.objects.name || '%'
            AND project_spaces.creator_id = auth.uid()
        )
    )
);

-- Policy: Project members can upload call sheets
DROP POLICY IF EXISTS "Project members can upload call sheets" ON storage.objects;
CREATE POLICY "Project members can upload call sheets"
ON storage.objects FOR INSERT
WITH CHECK (
    bucket_id = 'call-sheets' AND
    auth.uid() IS NOT NULL
);

-- Policy: Project members can update call sheets
DROP POLICY IF EXISTS "Project members can update call sheets" ON storage.objects;
CREATE POLICY "Project members can update call sheets"
ON storage.objects FOR UPDATE
USING (
    bucket_id = 'call-sheets' AND
    auth.uid() IS NOT NULL
);

-- Policy: Uploaders and project creators can delete call sheets
DROP POLICY IF EXISTS "Uploaders can delete call sheets" ON storage.objects;
CREATE POLICY "Uploaders can delete call sheets"
ON storage.objects FOR DELETE
USING (
    bucket_id = 'call-sheets' AND
    (owner = auth.uid() OR EXISTS (
        SELECT 1 FROM public.call_sheets
        JOIN public.project_spaces ON call_sheets.project_id = project_spaces.id
        WHERE call_sheets.notes LIKE '%' || storage.objects.name || '%'
        AND project_spaces.creator_id = auth.uid()
    ))
);


-- ============================================================================
-- Migration: 20251201000010_create_project_invites.sql
-- ============================================================================
-- Create project_invites table for invite link management
CREATE TABLE IF NOT EXISTS public.project_invites (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    invite_code text NOT NULL UNIQUE,
    created_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    expires_at timestamp with time zone,
    max_uses integer DEFAULT NULL,
    used_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Enable RLS
ALTER TABLE public.project_invites ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Project members can view invites"
ON public.project_invites FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members
        WHERE project_space_id = project_invites.project_id
        AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces
        WHERE id = project_invites.project_id
        AND creator_id = auth.uid()
    )
);

CREATE POLICY "Project creators can create invites"
ON public.project_invites FOR INSERT
WITH CHECK (
    EXISTS (
        SELECT 1 FROM public.project_spaces
        WHERE id = project_id
        AND creator_id = auth.uid()
    )
);

CREATE POLICY "Project creators can delete invites"
ON public.project_invites FOR DELETE
USING (
    EXISTS (
        SELECT 1 FROM public.project_spaces
        WHERE id = project_invites.project_id
        AND creator_id = auth.uid()
    )
);

-- Create updated_at trigger
CREATE TRIGGER update_project_invites_updated_at
BEFORE UPDATE ON public.project_invites
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();


-- ============================================================================
-- Migration: 20251201000011_create_project_applications.sql
-- ============================================================================
-- Create project_applications table
CREATE TABLE IF NOT EXISTS public.project_applications (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    cover_letter text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE(project_id, user_id)
);

-- Enable RLS
ALTER TABLE public.project_applications ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view applications to their projects"
ON public.project_applications FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM public.project_spaces
        WHERE id = project_applications.project_id
        AND creator_id = auth.uid()
    ) OR user_id = auth.uid()
);

CREATE POLICY "Users can create applications"
ON public.project_applications FOR INSERT
WITH CHECK (
    user_id = auth.uid() AND
    NOT EXISTS (
        SELECT 1 FROM public.project_space_members
        WHERE project_space_id = project_id
        AND user_id = auth.uid()
    )
);

CREATE POLICY "Project creators can update applications"
ON public.project_applications FOR UPDATE
USING (
    EXISTS (
        SELECT 1 FROM public.project_spaces
        WHERE id = project_applications.project_id
        AND creator_id = auth.uid()
    )
);

CREATE POLICY "Applicants can delete their own applications"
ON public.project_applications FOR DELETE
USING (user_id = auth.uid());

-- Create updated_at trigger
CREATE TRIGGER update_project_applications_updated_at
BEFORE UPDATE ON public.project_applications
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();


-- ============================================================================
-- Migration: 20251201000012_create_project_messages.sql
-- ============================================================================
-- Create project_messages table for project-specific chat
CREATE TABLE IF NOT EXISTS public.project_messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    content text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Create index for faster queries
CREATE INDEX IF NOT EXISTS idx_project_messages_project_id ON public.project_messages(project_id);
CREATE INDEX IF NOT EXISTS idx_project_messages_created_at ON public.project_messages(created_at);

-- Enable RLS
ALTER TABLE public.project_messages ENABLE ROW LEVEL SECURITY;

-- RLS Policies - Only project members can access messages
CREATE POLICY "Project members can view messages"
ON public.project_messages FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM public.project_space_members
        WHERE project_space_id = project_messages.project_id
        AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM public.project_spaces
        WHERE id = project_messages.project_id
        AND creator_id = auth.uid()
    )
);

CREATE POLICY "Project members can send messages"
ON public.project_messages FOR INSERT
WITH CHECK (
    user_id = auth.uid() AND
    (
        EXISTS (
            SELECT 1 FROM public.project_space_members
            WHERE project_space_id = project_id
            AND user_id = auth.uid()
        ) OR EXISTS (
            SELECT 1 FROM public.project_spaces
            WHERE id = project_id
            AND creator_id = auth.uid()
        )
    )
);

CREATE POLICY "Users can delete their own messages"
ON public.project_messages FOR DELETE
USING (user_id = auth.uid());

-- Create updated_at trigger
CREATE TRIGGER update_project_messages_updated_at
BEFORE UPDATE ON public.project_messages
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();


-- ============================================================================
-- Migration: 20251201000013_add_username_onboarding.sql
-- ============================================================================
-- Add username and onboarding_completed columns to profiles table
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS username TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS onboarding_completed BOOLEAN DEFAULT FALSE;

-- Create index on username for faster lookups
CREATE INDEX IF NOT EXISTS idx_profiles_username ON public.profiles(username);

-- Add constraint to ensure username is lowercase and valid format
ALTER TABLE public.profiles 
ADD CONSTRAINT username_format CHECK (username ~ '^[a-z0-9_]{3,20}$');


-- ============================================================================
-- Migration: 20251201000014_create_calls_system.sql
-- ============================================================================
-- Create calls table for managing video/voice calls
CREATE TABLE IF NOT EXISTS public.calls (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    room_type text NOT NULL CHECK (room_type IN ('project', 'discussion')),
    room_id uuid NOT NULL, -- project_id or discussion_room_id
    daily_room_name text UNIQUE NOT NULL,
    daily_room_url text NOT NULL,
    status text NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'ended')),
    started_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    started_at timestamptz DEFAULT now() NOT NULL,
    ended_at timestamptz,
    created_at timestamptz DEFAULT now() NOT NULL
);

-- Create call_participants table for tracking who's in the call
CREATE TABLE IF NOT EXISTS public.call_participants (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    call_id uuid NOT NULL REFERENCES public.calls(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    status text NOT NULL DEFAULT 'joined' CHECK (status IN ('requesting', 'joined', 'left')),
    joined_at timestamptz DEFAULT now() NOT NULL,
    left_at timestamptz,
    UNIQUE(call_id, user_id)
);

-- Create call_reactions table for emoji reactions during calls
CREATE TABLE IF NOT EXISTS public.call_reactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    call_id uuid NOT NULL REFERENCES public.calls(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    emoji text NOT NULL,
    created_at timestamptz DEFAULT now() NOT NULL
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_calls_room ON public.calls(room_type, room_id);
CREATE INDEX IF NOT EXISTS idx_calls_status ON public.calls(status);
CREATE INDEX IF NOT EXISTS idx_call_participants_call_id ON public.call_participants(call_id);
CREATE INDEX IF NOT EXISTS idx_call_participants_user_id ON public.call_participants(user_id);
CREATE INDEX IF NOT EXISTS idx_call_reactions_call_id ON public.call_reactions(call_id);

-- Enable RLS
ALTER TABLE public.calls ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.call_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.call_reactions ENABLE ROW LEVEL SECURITY;

-- RLS Policies for calls table
CREATE POLICY "Users can view calls in their projects/rooms"
ON public.calls FOR SELECT
USING (
    (room_type = 'project' AND EXISTS (
        SELECT 1 FROM public.project_space_members
        WHERE project_space_id = room_id AND user_id = auth.uid()
    )) OR
    (room_type = 'project' AND EXISTS (
        SELECT 1 FROM public.project_spaces
        WHERE id = room_id AND creator_id = auth.uid()
    )) OR
    (room_type = 'discussion' AND EXISTS (
        SELECT 1 FROM public.room_members
        WHERE room_id = calls.room_id AND user_id = auth.uid()
    ))
);

CREATE POLICY "Project/room members can create calls"
ON public.calls FOR INSERT
WITH CHECK (
    (room_type = 'project' AND (
        EXISTS (
            SELECT 1 FROM public.project_space_members
            WHERE project_space_id = room_id AND user_id = auth.uid()
        ) OR EXISTS (
            SELECT 1 FROM public.project_spaces
            WHERE id = room_id AND creator_id = auth.uid()
        )
    )) OR
    (room_type = 'discussion' AND EXISTS (
        SELECT 1 FROM public.room_members
        WHERE room_id = calls.room_id AND user_id = auth.uid()
    ))
);

CREATE POLICY "Call creator can update call"
ON public.calls FOR UPDATE
USING (started_by = auth.uid());

-- RLS Policies for call_participants table
CREATE POLICY "Users can view participants in their calls"
ON public.call_participants FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM public.calls
        WHERE id = call_id AND (
            (room_type = 'project' AND (
                EXISTS (
                    SELECT 1 FROM public.project_space_members
                    WHERE project_space_id = room_id AND user_id = auth.uid()
                ) OR EXISTS (
                    SELECT 1 FROM public.project_spaces
                    WHERE id = room_id AND creator_id = auth.uid()
                )
            )) OR
            (room_type = 'discussion' AND EXISTS (
                SELECT 1 FROM public.room_members
                WHERE room_id = calls.room_id AND user_id = auth.uid()
            ))
        )
    )
);

CREATE POLICY "Users can join calls"
ON public.call_participants FOR INSERT
WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own participation"
ON public.call_participants FOR UPDATE
USING (user_id = auth.uid());

-- RLS Policies for call_reactions table
CREATE POLICY "Users can view reactions in their calls"
ON public.call_reactions FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM public.calls
        WHERE id = call_id AND (
            (room_type = 'project' AND (
                EXISTS (
                    SELECT 1 FROM public.project_space_members
                    WHERE project_space_id = room_id AND user_id = auth.uid()
                ) OR EXISTS (
                    SELECT 1 FROM public.project_spaces
                    WHERE id = room_id AND creator_id = auth.uid()
                )
            )) OR
            (room_type = 'discussion' AND EXISTS (
                SELECT 1 FROM public.room_members
                WHERE room_id = calls.room_id AND user_id = auth.uid()
            ))
        )
    )
);

CREATE POLICY "Users can create reactions in calls they're in"
ON public.call_reactions FOR INSERT
WITH CHECK (
    user_id = auth.uid() AND
    EXISTS (
        SELECT 1 FROM public.call_participants
        WHERE call_id = call_reactions.call_id 
        AND user_id = auth.uid() 
        AND status = 'joined'
    )
);


-- ============================================================================
-- Migration: 20251201000015_add_unread_messages_rpc.sql
-- ============================================================================
-- Function to check if the current user has any unread messages
-- This is a placeholder implementation to fix the 404 error
-- In a real implementation, this would check message read status tables

CREATE OR REPLACE FUNCTION public.has_unread_messages()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- For now, just return false
  -- You can implement actual unread logic here later
  RETURN false;
END;
$$;

GRANT EXECUTE ON FUNCTION public.has_unread_messages() TO authenticated;
GRANT EXECUTE ON FUNCTION public.has_unread_messages() TO anon;


-- ============================================================================
-- Migration: 20251201000016_fix_project_messages_fk.sql
-- ============================================================================
-- Fix project_messages foreign key to reference profiles instead of auth.users
-- This allows PostgREST to automatically detect the relationship for joins

ALTER TABLE public.project_messages
DROP CONSTRAINT project_messages_user_id_fkey;

ALTER TABLE public.project_messages
ADD CONSTRAINT project_messages_user_id_fkey
FOREIGN KEY (user_id)
REFERENCES public.profiles(id)
ON DELETE CASCADE;

-- Re-define has_unread_messages RPC to ensure it exists
CREATE OR REPLACE FUNCTION public.has_unread_messages()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Placeholder implementation
  RETURN false;
END;
$$;

GRANT EXECUTE ON FUNCTION public.has_unread_messages() TO authenticated;
GRANT EXECUTE ON FUNCTION public.has_unread_messages() TO anon;


-- ============================================================================
-- Migration: 20251201000017_fix_project_applications_fk.sql
-- ============================================================================
-- Fix project_applications foreign key to reference profiles instead of auth.users
-- This allows PostgREST to correctly join project_applications with profiles

ALTER TABLE public.project_applications
DROP CONSTRAINT IF EXISTS project_applications_user_id_fkey;

ALTER TABLE public.project_applications
ADD CONSTRAINT project_applications_user_id_fkey
FOREIGN KEY (user_id)
REFERENCES public.profiles(id)
ON DELETE CASCADE;


-- ============================================================================
-- Migration: 20251201000018_cleanup_test_data.sql
-- ============================================================================
-- Clean up all application data
-- This migration removes all test data to provide a fresh start

-- 1. Truncate content tables (CASCADE handles dependent tables like tasks, messages, etc.)
TRUNCATE TABLE public.project_spaces CASCADE;
TRUNCATE TABLE public.discussion_rooms CASCADE;
TRUNCATE TABLE public.posts CASCADE;
TRUNCATE TABLE public.user_connections CASCADE;
TRUNCATE TABLE public.notifications CASCADE;
TRUNCATE TABLE public.conversations CASCADE;
TRUNCATE TABLE public.announcements CASCADE;

-- 2. Delete all users (This will cascade to profiles and any remaining user-linked data)
-- Note: This requires the migration to run with sufficient privileges (which local Supabase migrations do)
DELETE FROM auth.users;

-- 3. Clean up storage objects (Optional, but good for a full reset)
-- We delete objects from specific buckets used by the app
DELETE FROM storage.objects 
WHERE bucket_id IN ('project-files', 'call-sheets', 'legal-docs', 'avatars', 'post-media');


-- ============================================================================
-- Migration: 20251201000019_create_marketplace_economy.sql
-- ============================================================================
-- Create enums for marketplace (with IF NOT EXISTS check)
DO $$ BEGIN
  CREATE TYPE listing_type AS ENUM ('equipment', 'location');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE TYPE booking_status AS ENUM ('pending', 'confirmed', 'cancelled', 'completed');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Create marketplace_listings table
CREATE TABLE IF NOT EXISTS marketplace_listings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  listing_type listing_type NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  category TEXT NOT NULL,
  price_per_day NUMERIC(10, 2) NOT NULL,
  price_per_week NUMERIC(10, 2),
  location TEXT NOT NULL,
  images TEXT[] DEFAULT '{}',
  specifications JSONB DEFAULT '{}',
  availability_calendar JSONB DEFAULT '{}',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create marketplace_bookings table
CREATE TABLE IF NOT EXISTS marketplace_bookings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  listing_id UUID NOT NULL REFERENCES marketplace_listings(id) ON DELETE CASCADE,
  renter_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  total_price NUMERIC(10, 2) NOT NULL,
  status booking_status DEFAULT 'pending',
  message TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT valid_date_range CHECK (end_date >= start_date)
);

-- Create vendors table
CREATE TABLE IF NOT EXISTS vendors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  business_name TEXT NOT NULL,
  description TEXT NOT NULL,
  category TEXT[] NOT NULL,
  services_offered TEXT[] DEFAULT '{}',
  location TEXT NOT NULL,
  address TEXT,
  phone TEXT NOT NULL,
  email TEXT NOT NULL,
  website TEXT,
  logo_url TEXT,
  images TEXT[] DEFAULT '{}',
  is_verified BOOLEAN DEFAULT false,
  verification_date TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create marketplace_reviews table
CREATE TABLE IF NOT EXISTS marketplace_reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  listing_id UUID REFERENCES marketplace_listings(id) ON DELETE CASCADE,
  vendor_id UUID REFERENCES vendors(id) ON DELETE CASCADE,
  reviewer_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  review_text TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT review_target CHECK (
    (listing_id IS NOT NULL AND vendor_id IS NULL) OR
    (listing_id IS NULL AND vendor_id IS NOT NULL)
  )
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_marketplace_listings_user_id ON marketplace_listings(user_id);
CREATE INDEX IF NOT EXISTS idx_marketplace_listings_type ON marketplace_listings(listing_type);
CREATE INDEX IF NOT EXISTS idx_marketplace_listings_category ON marketplace_listings(category);
CREATE INDEX IF NOT EXISTS idx_marketplace_listings_location ON marketplace_listings(location);
CREATE INDEX IF NOT EXISTS idx_marketplace_listings_active ON marketplace_listings(is_active);

CREATE INDEX IF NOT EXISTS idx_marketplace_bookings_listing_id ON marketplace_bookings(listing_id);
CREATE INDEX IF NOT EXISTS idx_marketplace_bookings_renter_id ON marketplace_bookings(renter_id);
CREATE INDEX IF NOT EXISTS idx_marketplace_bookings_owner_id ON marketplace_bookings(owner_id);
CREATE INDEX IF NOT EXISTS idx_marketplace_bookings_status ON marketplace_bookings(status);

CREATE INDEX IF NOT EXISTS idx_vendors_owner_id ON vendors(owner_id);
CREATE INDEX IF NOT EXISTS idx_vendors_category ON vendors USING GIN(category);
CREATE INDEX IF NOT EXISTS idx_vendors_location ON vendors(location);
CREATE INDEX IF NOT EXISTS idx_vendors_verified ON vendors(is_verified);

CREATE INDEX IF NOT EXISTS idx_marketplace_reviews_listing_id ON marketplace_reviews(listing_id);
CREATE INDEX IF NOT EXISTS idx_marketplace_reviews_vendor_id ON marketplace_reviews(vendor_id);
CREATE INDEX IF NOT EXISTS idx_marketplace_reviews_reviewer_id ON marketplace_reviews(reviewer_id);

-- Create storage buckets
INSERT INTO storage.buckets (id, name, public)
VALUES 
  ('marketplace-images', 'marketplace-images', true),
  ('vendor-images', 'vendor-images', true)
ON CONFLICT (id) DO NOTHING;

-- Storage policies for marketplace-images bucket
DO $$ BEGIN
  CREATE POLICY "Anyone can view marketplace images"
    ON storage.objects FOR SELECT
    USING (bucket_id = 'marketplace-images');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Authenticated users can upload marketplace images"
    ON storage.objects FOR INSERT
    WITH CHECK (
      bucket_id = 'marketplace-images' AND
      auth.role() = 'authenticated'
    );
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can update their own marketplace images"
    ON storage.objects FOR UPDATE
    USING (
      bucket_id = 'marketplace-images' AND
      auth.uid()::text = (storage.foldername(name))[1]
    );
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can delete their own marketplace images"
    ON storage.objects FOR DELETE
    USING (
      bucket_id = 'marketplace-images' AND
      auth.uid()::text = (storage.foldername(name))[1]
    );
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Storage policies for vendor-images bucket
DO $$ BEGIN
  CREATE POLICY "Anyone can view vendor images"
    ON storage.objects FOR SELECT
    USING (bucket_id = 'vendor-images');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Authenticated users can upload vendor images"
    ON storage.objects FOR INSERT
    WITH CHECK (
      bucket_id = 'vendor-images' AND
      auth.role() = 'authenticated'
    );
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can update their own vendor images"
    ON storage.objects FOR UPDATE
    USING (
      bucket_id = 'vendor-images' AND
      auth.uid()::text = (storage.foldername(name))[1]
    );
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can delete their own vendor images"
    ON storage.objects FOR DELETE
    USING (
      bucket_id = 'vendor-images' AND
      auth.uid()::text = (storage.foldername(name))[1]
    );
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Enable RLS on all tables
ALTER TABLE marketplace_listings ENABLE ROW LEVEL SECURITY;
ALTER TABLE marketplace_bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE vendors ENABLE ROW LEVEL SECURITY;
ALTER TABLE marketplace_reviews ENABLE ROW LEVEL SECURITY;

-- RLS Policies for marketplace_listings
DO $$ BEGIN
  CREATE POLICY "Anyone can view active listings"
    ON marketplace_listings FOR SELECT
    USING (is_active = true OR user_id = auth.uid());
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can create their own listings"
    ON marketplace_listings FOR INSERT
    WITH CHECK (auth.uid() = user_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can update their own listings"
    ON marketplace_listings FOR UPDATE
    USING (auth.uid() = user_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can delete their own listings"
    ON marketplace_listings FOR DELETE
    USING (auth.uid() = user_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- RLS Policies for marketplace_bookings
DO $$ BEGIN
  CREATE POLICY "Users can view their own bookings"
    ON marketplace_bookings FOR SELECT
    USING (auth.uid() = renter_id OR auth.uid() = owner_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can create bookings"
    ON marketplace_bookings FOR INSERT
    WITH CHECK (auth.uid() = renter_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Owners and renters can update bookings"
    ON marketplace_bookings FOR UPDATE
    USING (auth.uid() = renter_id OR auth.uid() = owner_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- RLS Policies for vendors
DO $$ BEGIN
  CREATE POLICY "Anyone can view verified vendors"
    ON vendors FOR SELECT
    USING (is_verified = true OR owner_id = auth.uid());
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can create vendor profiles"
    ON vendors FOR INSERT
    WITH CHECK (auth.uid() = owner_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Owners can update their vendor profiles"
    ON vendors FOR UPDATE
    USING (auth.uid() = owner_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Owners can delete their vendor profiles"
    ON vendors FOR DELETE
    USING (auth.uid() = owner_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- RLS Policies for marketplace_reviews
DO $$ BEGIN
  CREATE POLICY "Anyone can view reviews"
    ON marketplace_reviews FOR SELECT
    USING (true);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can create reviews"
    ON marketplace_reviews FOR INSERT
    WITH CHECK (auth.uid() = reviewer_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can update their own reviews"
    ON marketplace_reviews FOR UPDATE
    USING (auth.uid() = reviewer_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE POLICY "Users can delete their own reviews"
    ON marketplace_reviews FOR DELETE
    USING (auth.uid() = reviewer_id);
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for updated_at
DROP TRIGGER IF EXISTS update_marketplace_listings_updated_at ON marketplace_listings;
CREATE TRIGGER update_marketplace_listings_updated_at
  BEFORE UPDATE ON marketplace_listings
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_marketplace_bookings_updated_at ON marketplace_bookings;
CREATE TRIGGER update_marketplace_bookings_updated_at
  BEFORE UPDATE ON marketplace_bookings
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_vendors_updated_at ON vendors;
CREATE TRIGGER update_vendors_updated_at
  BEFORE UPDATE ON vendors
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create function to get listing with average rating
CREATE OR REPLACE FUNCTION get_listing_with_rating(listing_uuid UUID)
RETURNS TABLE (
  id UUID,
  user_id UUID,
  listing_type listing_type,
  title TEXT,
  description TEXT,
  category TEXT,
  price_per_day NUMERIC,
  price_per_week NUMERIC,
  location TEXT,
  images TEXT[],
  specifications JSONB,
  availability_calendar JSONB,
  is_active BOOLEAN,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ,
  average_rating NUMERIC,
  review_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ml.*,
    COALESCE(AVG(mr.rating), 0)::NUMERIC as average_rating,
    COUNT(mr.id) as review_count
  FROM marketplace_listings ml
  LEFT JOIN marketplace_reviews mr ON ml.id = mr.listing_id
  WHERE ml.id = listing_uuid
  GROUP BY ml.id;
END;
$$ LANGUAGE plpgsql;

-- Create function to get vendor with average rating
CREATE OR REPLACE FUNCTION get_vendor_with_rating(vendor_uuid UUID)
RETURNS TABLE (
  id UUID,
  owner_id UUID,
  business_name TEXT,
  description TEXT,
  category TEXT[],
  services_offered TEXT[],
  location TEXT,
  address TEXT,
  phone TEXT,
  email TEXT,
  website TEXT,
  logo_url TEXT,
  images TEXT[],
  is_verified BOOLEAN,
  verification_date TIMESTAMPTZ,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ,
  average_rating NUMERIC,
  review_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    v.*,
    COALESCE(AVG(mr.rating), 0)::NUMERIC as average_rating,
    COUNT(mr.id) as review_count
  FROM vendors v
  LEFT JOIN marketplace_reviews mr ON v.id = mr.vendor_id
  WHERE v.id = vendor_uuid
  GROUP BY v.id;
END;
$$ LANGUAGE plpgsql;

-- Create function to search marketplace listings
CREATE OR REPLACE FUNCTION search_marketplace_listings(
  search_query TEXT DEFAULT NULL,
  filter_type listing_type DEFAULT NULL,
  filter_category TEXT DEFAULT NULL,
  filter_location TEXT DEFAULT NULL,
  min_price NUMERIC DEFAULT NULL,
  max_price NUMERIC DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  user_id UUID,
  listing_type listing_type,
  title TEXT,
  description TEXT,
  category TEXT,
  price_per_day NUMERIC,
  price_per_week NUMERIC,
  location TEXT,
  images TEXT[],
  is_active BOOLEAN,
  created_at TIMESTAMPTZ,
  average_rating NUMERIC,
  review_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ml.id,
    ml.user_id,
    ml.listing_type,
    ml.title,
    ml.description,
    ml.category,
    ml.price_per_day,
    ml.price_per_week,
    ml.location,
    ml.images,
    ml.is_active,
    ml.created_at,
    COALESCE(AVG(mr.rating), 0)::NUMERIC as average_rating,
    COUNT(mr.id) as review_count
  FROM marketplace_listings ml
  LEFT JOIN marketplace_reviews mr ON ml.id = mr.listing_id
  WHERE 
    ml.is_active = true
    AND (search_query IS NULL OR ml.title ILIKE '%' || search_query || '%' OR ml.description ILIKE '%' || search_query || '%')
    AND (filter_type IS NULL OR ml.listing_type = filter_type)
    AND (filter_category IS NULL OR ml.category = filter_category)
    AND (filter_location IS NULL OR ml.location ILIKE '%' || filter_location || '%')
    AND (min_price IS NULL OR ml.price_per_day >= min_price)
    AND (max_price IS NULL OR ml.price_per_day <= max_price)
  GROUP BY ml.id
  ORDER BY ml.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Create function to search vendors
CREATE OR REPLACE FUNCTION search_vendors(
  search_query TEXT DEFAULT NULL,
  filter_category TEXT DEFAULT NULL,
  filter_location TEXT DEFAULT NULL,
  verified_only BOOLEAN DEFAULT false
)
RETURNS TABLE (
  id UUID,
  owner_id UUID,
  business_name TEXT,
  description TEXT,
  category TEXT[],
  services_offered TEXT[],
  location TEXT,
  phone TEXT,
  email TEXT,
  website TEXT,
  logo_url TEXT,
  images TEXT[],
  is_verified BOOLEAN,
  created_at TIMESTAMPTZ,
  average_rating NUMERIC,
  review_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    v.id,
    v.owner_id,
    v.business_name,
    v.description,
    v.category,
    v.services_offered,
    v.location,
    v.phone,
    v.email,
    v.website,
    v.logo_url,
    v.images,
    v.is_verified,
    v.created_at,
    COALESCE(AVG(mr.rating), 0)::NUMERIC as average_rating,
    COUNT(mr.id) as review_count
  FROM vendors v
  LEFT JOIN marketplace_reviews mr ON v.id = mr.vendor_id
  WHERE 
    (NOT verified_only OR v.is_verified = true)
    AND (search_query IS NULL OR v.business_name ILIKE '%' || search_query || '%' OR v.description ILIKE '%' || search_query || '%')
    AND (filter_category IS NULL OR filter_category = ANY(v.category))
    AND (filter_location IS NULL OR v.location ILIKE '%' || filter_location || '%')
  GROUP BY v.id
  ORDER BY v.is_verified DESC, v.created_at DESC;
END;
$$ LANGUAGE plpgsql;


-- ============================================================================
-- Migration: 20251202000001_create_jobs_table.sql
-- ============================================================================
-- Create Enums
CREATE TYPE job_type AS ENUM ('full-time', 'part-time', 'contract', 'freelance', 'internship', 'project-based');
CREATE TYPE experience_level AS ENUM ('entry', 'junior', 'mid', 'senior', 'lead');

-- Create Jobs Table
CREATE TABLE jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    company TEXT NOT NULL,
    location TEXT,
    type job_type NOT NULL DEFAULT 'full-time',
    salary_min NUMERIC,
    salary_max NUMERIC,
    experience_level experience_level NOT NULL DEFAULT 'mid',
    requirements TEXT,
    posted_by UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    is_active BOOLEAN DEFAULT true
);

-- Enable RLS
ALTER TABLE jobs ENABLE ROW LEVEL SECURITY;

-- Create Policies
-- Everyone can view active jobs
CREATE POLICY "Jobs are viewable by everyone" 
ON jobs FOR SELECT 
USING (is_active = true);

-- Authenticated users can create jobs
CREATE POLICY "Users can create jobs" 
ON jobs FOR INSERT 
TO authenticated 
WITH CHECK (auth.uid() = posted_by);

-- Users can update their own jobs
CREATE POLICY "Users can update own jobs" 
ON jobs FOR UPDATE 
TO authenticated 
USING (auth.uid() = posted_by);

-- Users can delete their own jobs
CREATE POLICY "Users can delete own jobs" 
ON jobs FOR DELETE 
TO authenticated 
USING (auth.uid() = posted_by);

-- Create Updated At Trigger
CREATE TRIGGER update_jobs_updated_at
    BEFORE UPDATE ON jobs
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


-- ============================================================================
-- Migration: 20251202000002_create_job_applications.sql
-- ============================================================================
-- Create Enum
DO $$ BEGIN
    CREATE TYPE job_application_status AS ENUM ('pending', 'reviewing', 'interviewing', 'accepted', 'rejected');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Create Job Applications Table
CREATE TABLE IF NOT EXISTS job_applications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    job_id UUID NOT NULL REFERENCES jobs(id) ON DELETE CASCADE,
    applicant_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    cover_letter TEXT,
    resume_url TEXT,
    status job_application_status NOT NULL DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(job_id, applicant_id)
);

-- Enable RLS
ALTER TABLE job_applications ENABLE ROW LEVEL SECURITY;

-- Create Policies

-- Applicants can view their own applications
DROP POLICY IF EXISTS "Applicants can view own applications" ON job_applications;
CREATE POLICY "Applicants can view own applications" 
ON job_applications FOR SELECT 
TO authenticated 
USING (auth.uid() = applicant_id);

-- Job posters can view applications for their jobs
DROP POLICY IF EXISTS "Job posters can view applications" ON job_applications;
CREATE POLICY "Job posters can view applications" 
ON job_applications FOR SELECT 
TO authenticated 
USING (
    EXISTS (
        SELECT 1 FROM jobs 
        WHERE jobs.id = job_applications.job_id 
        AND jobs.posted_by = auth.uid()
    )
);

-- Authenticated users can create applications
DROP POLICY IF EXISTS "Users can create applications" ON job_applications;
CREATE POLICY "Users can create applications" 
ON job_applications FOR INSERT 
TO authenticated 
WITH CHECK (auth.uid() = applicant_id);

-- Job posters can update status
DROP POLICY IF EXISTS "Job posters can update status" ON job_applications;
CREATE POLICY "Job posters can update status" 
ON job_applications FOR UPDATE 
TO authenticated 
USING (
    EXISTS (
        SELECT 1 FROM jobs 
        WHERE jobs.id = job_applications.job_id 
        AND jobs.posted_by = auth.uid()
    )
);

-- Create Storage Bucket for Resumes
INSERT INTO storage.buckets (id, name, public) 
VALUES ('resumes', 'resumes', true)
ON CONFLICT (id) DO NOTHING;

-- Storage Policies
DROP POLICY IF EXISTS "Resume Access" ON storage.objects;
CREATE POLICY "Resume Access"
ON storage.objects FOR SELECT
TO authenticated
USING ( bucket_id = 'resumes' );

DROP POLICY IF EXISTS "Resume Upload" ON storage.objects;
CREATE POLICY "Resume Upload"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'resumes' AND auth.uid()::text = (storage.foldername(name))[1] );

-- Create Updated At Trigger
DROP TRIGGER IF EXISTS update_job_applications_updated_at ON job_applications;
CREATE TRIGGER update_job_applications_updated_at
    BEFORE UPDATE ON job_applications
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


-- ============================================================================
-- Migration: 20251202000003_add_social_links_to_profiles.sql
-- ============================================================================
-- Add social_links column to profiles table
ALTER TABLE profiles 
ADD COLUMN IF NOT EXISTS social_links JSONB DEFAULT '{}'::jsonb;


-- ============================================================================
-- Migration: 20251202000004_fix_post_comments_relationship.sql
-- ============================================================================
-- Ensure post_comments table exists
CREATE TABLE IF NOT EXISTS public.post_comments (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id uuid NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content text NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.post_comments ENABLE ROW LEVEL SECURITY;

-- Policies
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'post_comments' AND policyname = 'Public view post_comments'
    ) THEN
        CREATE POLICY "Public view post_comments" ON public.post_comments FOR SELECT USING (true);
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'post_comments' AND policyname = 'Authenticated users can create post_comments'
    ) THEN
        CREATE POLICY "Authenticated users can create post_comments" ON public.post_comments FOR INSERT WITH CHECK (auth.uid() = user_id);
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'post_comments' AND policyname = 'Users can update own post_comments'
    ) THEN
        CREATE POLICY "Users can update own post_comments" ON public.post_comments FOR UPDATE USING (auth.uid() = user_id);
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'post_comments' AND policyname = 'Users can delete own post_comments'
    ) THEN
        CREATE POLICY "Users can delete own post_comments" ON public.post_comments FOR DELETE USING (auth.uid() = user_id);
    END IF;
END $$;

-- Ensure Foreign Key to profiles exists
DO $$
BEGIN
    -- Check if the constraint already exists
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint WHERE conname = 'post_comments_user_id_fkey_profiles'
    ) THEN
        -- If user_id already references auth.users (from previous creation), we can add a second FK or replace it.
        -- Since profiles.id is same as auth.users.id, referencing profiles is safe and preferred for PostgREST embedding.
        
        -- We'll try to add it. If user_id references auth.users, it's fine.
        -- However, if the table was created with REFERENCES auth.users(id), it has a FK.
        -- We want to ensure it explicitly references profiles for the embedding to work.
        
        ALTER TABLE public.post_comments 
        ADD CONSTRAINT post_comments_user_id_fkey_profiles 
        FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
    END IF;
END $$;


-- ============================================================================
-- Migration: 20251202000005_add_post_stats_triggers.sql
-- ============================================================================
-- Ensure post_likes table exists (if not already created by another migration)
CREATE TABLE IF NOT EXISTS public.post_likes (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id uuid NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    UNIQUE (post_id, user_id)
);

-- Enable RLS on post_likes
ALTER TABLE public.post_likes ENABLE ROW LEVEL SECURITY;

-- Policies for post_likes
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'post_likes' AND policyname = 'Public view post_likes'
    ) THEN
        CREATE POLICY "Public view post_likes" ON public.post_likes FOR SELECT USING (true);
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'post_likes' AND policyname = 'Authenticated users can create post_likes'
    ) THEN
        CREATE POLICY "Authenticated users can create post_likes" ON public.post_likes FOR INSERT WITH CHECK (auth.uid() = user_id);
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'post_likes' AND policyname = 'Users can delete own post_likes'
    ) THEN
        CREATE POLICY "Users can delete own post_likes" ON public.post_likes FOR DELETE USING (auth.uid() = user_id);
    END IF;
END $$;

-- Function to update post like count
CREATE OR REPLACE FUNCTION public.update_post_like_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.posts
        SET like_count = like_count + 1
        WHERE id = NEW.post_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.posts
        SET like_count = GREATEST(0, like_count - 1)
        WHERE id = OLD.post_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger for post_likes
DROP TRIGGER IF EXISTS update_post_like_count_on_insert ON public.post_likes;
CREATE TRIGGER update_post_like_count_on_insert
AFTER INSERT ON public.post_likes
FOR EACH ROW
EXECUTE FUNCTION public.update_post_like_count();

DROP TRIGGER IF EXISTS update_post_like_count_on_delete ON public.post_likes;
CREATE TRIGGER update_post_like_count_on_delete
AFTER DELETE ON public.post_likes
FOR EACH ROW
EXECUTE FUNCTION public.update_post_like_count();

-- Function to update post comment count
CREATE OR REPLACE FUNCTION public.update_post_comment_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.posts
        SET comment_count = comment_count + 1
        WHERE id = NEW.post_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.posts
        SET comment_count = GREATEST(0, comment_count - 1)
        WHERE id = OLD.post_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger for post_comments
DROP TRIGGER IF EXISTS update_post_comment_count_on_insert ON public.post_comments;
CREATE TRIGGER update_post_comment_count_on_insert
AFTER INSERT ON public.post_comments
FOR EACH ROW
EXECUTE FUNCTION public.update_post_comment_count();

DROP TRIGGER IF EXISTS update_post_comment_count_on_delete ON public.post_comments;
CREATE TRIGGER update_post_comment_count_on_delete
AFTER DELETE ON public.post_comments
FOR EACH ROW
EXECUTE FUNCTION public.update_post_comment_count();

-- Backfill counts (optional but good for consistency)
UPDATE public.posts p
SET 
    like_count = (SELECT COUNT(*) FROM public.post_likes pl WHERE pl.post_id = p.id),
    comment_count = (SELECT COUNT(*) FROM public.post_comments pc WHERE pc.post_id = p.id);


-- ============================================================================
-- Migration: 20251202000006_fix_announcements_fk.sql
-- ============================================================================
-- Fix announcements foreign key to reference profiles instead of auth.users
ALTER TABLE public.announcements
DROP CONSTRAINT IF EXISTS announcements_author_id_fkey;

ALTER TABLE public.announcements
ADD CONSTRAINT announcements_author_id_fkey
FOREIGN KEY (author_id)
REFERENCES public.profiles(id)
ON DELETE SET NULL;


-- ============================================================================
-- Migration: 20251202000007_create_user_analytics.sql
-- ============================================================================
-- Create user_analytics table
CREATE TABLE IF NOT EXISTS public.user_analytics (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    event_type text NOT NULL,
    event_data jsonb DEFAULT '{}'::jsonb,
    page_url text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Enable RLS
ALTER TABLE public.user_analytics ENABLE ROW LEVEL SECURITY;

-- Create Policies
DROP POLICY IF EXISTS "Users can insert their own analytics" ON public.user_analytics;
CREATE POLICY "Users can insert their own analytics"
ON public.user_analytics FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can view their own analytics" ON public.user_analytics;
CREATE POLICY "Users can view their own analytics"
ON public.user_analytics FOR SELECT
TO authenticated
USING (auth.uid() = user_id);


-- ============================================================================
-- Migration: 20251203000000_add_missing_profile_columns.sql
-- ============================================================================
-- Add full_name column to profiles if it doesn't exist
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS full_name text;

-- Add onboarding_completed column if it doesn't exist  
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS onboarding_completed boolean DEFAULT false;

-- Add phone column if it doesn't exist
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS phone text;


-- ============================================================================
-- Migration: 20251204000000_ensure_project_space_bookmarks.sql
-- ============================================================================
-- Create project_space_bookmarks table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.project_space_bookmarks (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    project_space_id uuid NOT NULL REFERENCES public.project_spaces(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE(user_id, project_space_id)
);

-- Enable RLS
ALTER TABLE public.project_space_bookmarks ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can manage their own bookmarks" ON public.project_space_bookmarks;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON public.project_space_bookmarks;
DROP POLICY IF EXISTS "Anyone can view bookmarks" ON public.project_space_bookmarks;
DROP POLICY IF EXISTS "Users can create their own bookmarks" ON public.project_space_bookmarks;
DROP POLICY IF EXISTS "Users can delete their own bookmarks" ON public.project_space_bookmarks;

-- Create RLS policies
-- Allow anyone to view bookmarks (needed for the left join to work)
CREATE POLICY "Anyone can view bookmarks" 
ON public.project_space_bookmarks 
FOR SELECT 
USING (true);

-- Users can only insert their own bookmarks
CREATE POLICY "Users can create their own bookmarks" 
ON public.project_space_bookmarks 
FOR INSERT 
WITH CHECK (auth.uid() = user_id);

-- Users can only delete their own bookmarks
CREATE POLICY "Users can delete their own bookmarks" 
ON public.project_space_bookmarks 
FOR DELETE 
USING (auth.uid() = user_id);

-- Create index for better query performance
CREATE INDEX IF NOT EXISTS idx_project_space_bookmarks_user_id 
ON public.project_space_bookmarks(user_id);

CREATE INDEX IF NOT EXISTS idx_project_space_bookmarks_project_space_id 
ON public.project_space_bookmarks(project_space_id);



